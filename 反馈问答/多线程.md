# 1. 线程创建的方式

1. 继承Thread，重写run方法
2. 实现Runnable

使用第二种方式比较好，耦合度比较低。

# 2. 线程的同步锁

## 2.1 解决问题

多线程操作共享变量时，保证线程安全，将线程的并发执行改为串行化。

## 2.2 实现方式

### 2.2.1 Synchronized 

锁对象的区别：

```
同步代码块：添加锁的时候，锁对象可以是任意的对象，但是要保证多个线程间使用的是统一把锁
方法上：当前的锁对象是this(对象本身)
静态方法：类.class字节码文件对象
```

### 2.2.2 Lock

优点：

```
1. 相比Synchronized更加的灵活
2. 实现非阻塞锁
3. 实现超时锁
```

Lock底层的实现机制

```
volatile+Cas算法
volatile作用：保证共享变量在多个线程间的可见性；不能保证共享变量的原子性操作(互斥性)。
Cas算法作用：保证写操作的原子性。
```

# 3. 死锁

条件

```
1.2个线程，获得2把锁
2.线程1持有锁A，想要获得锁B
3.线程2持有锁B，想要获得锁A

结果：2个线程同时持有对象想要获得的锁，并且互不相让。
```

解决方案：重启。

避免：同一个线程尽量不要获得2个锁。

# 4. 线程安全的数据访问

## 4.1 条件

```
1. 存在共享变量
2. 多个线程同时进行写操作
```

## 4.2 解决方案

```
1.使用Synchronized
2.使用Lock
3.将普通的变量改为使用JDK中提供的原子类进行操作
```

# 5. 线程的等待唤醒机制

```
1. 多个线程共享同一把锁
2. 线程等待的方法锁对象.wait();
3. 线程唤醒的方法所对象.notify();
4. notify和notifyAll，前者是随机唤醒一个线程，后者是唤醒当前锁上的所有线程
```

## 5.1 Synchronized

```
锁对象.wait();	//等待
锁对象.notify();	//随机唤醒一个线程
锁对象.notifyAll()	//唤醒所有线程
```

## 5.2 Lock

```
Condition condition = lock.newCondition();	//获得condition
condition.await();	//等待
condition.signal();	//随机唤醒一个线程
condition.signalAll();	//唤醒所有线程
```

